{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>mabby is a library for simulating multi-armed bandits (MABs), a resource-allocation problem and framework in reinforcement learning. It allows users to quickly yet flexibly define and run bandit simulations, with the ability to:</p> <ul> <li>choose from a wide range of classic bandit algorithms to use</li> <li>configure environments with custom arm spaces and rewards distributions</li> <li>collect and visualize simulation metrics like regret and optimality</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Prerequisites: Python 3.9+ and <code>pip</code></p> <p>Install mabby with <code>pip</code>:</p> <pre><code>pip install mabby\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>The code example below demonstrates the basic steps of running a simulation with mabby. For more in-depth examples, please see the Usage Examples section of the mabby documentation.</p> <pre><code>import mabby as mb\n\n# configure bandit arms\nbandit = mb.BernoulliArm.bandit(p=[0.3, 0.6])\n\n# configure bandit strategy\nstrategy = mb.strategies.EpsilonGreedyStrategy(eps=0.2)\n\n# setup simulation\nsimulation = mb.Simulation(bandit=bandit, strategies=[strategy])\n\n# run simulation\nstats = simulation.run(trials=100, steps=300)\n\n# plot regret statistics\nstats.plot_regret()\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Please see CONTRIBUTING for more information.</p>"},{"location":"#license","title":"License","text":"<p>This software is licensed under the Apache 2.0 license. Please see LICENSE for more information.</p>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,     and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the     overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or     advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email     address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a     professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at ew2664@columbia.edu. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome and value all types of contributions, from bug reports to feature additions. Please make sure to read the relevant section(s) below before making your contribution.</p> <p>And if you like the project but just don't have time to contribute, there are other easy ways to support the project and show your appreciation. We'd love if you could:</p> <ul> <li>Star the project</li> <li>Refer this project in your project's README</li> <li>Mention the project at local meetups and tell your friends/colleagues</li> </ul> <p>Once again, thank you for supporting the project and taking the time to contribute!</p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please read and follow our Code of Conduct.</p>"},{"location":"contributing/#reporting-bugs","title":"Reporting Bugs","text":"<p>When submitting a new bug report, please first search for an existing or similar report. If you believe you've come across a unique problem, then use one of our existing issue templates. Duplicate issues or issues that don't use one of our templates may get closed without a response.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>Before contributing, make sure you have Python 3.9+ and poetry installed.</p> <ol> <li> <p>Fork the repository on GitHub.</p> </li> <li> <p>Clone the repository from your GitHub.</p> </li> <li> <p>Setup development environment (<code>make install</code>).</p> </li> <li> <p>Setup pre-commit hooks (<code>poetry run pre-commit install</code>).</p> </li> <li> <p>Check out a new branch and make your modifications.</p> </li> <li> <p>Add test cases for all your changes.</p> </li> <li> <p>Run <code>make lint</code> and <code>make test</code> and ensure they pass.</p> <p>Tip</p> <p>Run <code>make format</code> to fix the linting errors that are auto-fixable.</p> <p>Tip</p> <p>Run <code>make coverage</code> to run unit tests only and generate an HTML coverage report.</p> </li> <li> <p>Commit your changes following our commit conventions.</p> </li> <li> <p>Push your changes to your fork of the repository.</p> </li> <li> <p>Open a pull request! </p> </li> </ol>"},{"location":"contributing/#commit-conventions","title":"Commit Conventions","text":"<p>We follow conventional commits. When opening a pull request, please be sure that both the pull request title and each commit in the pull request has one of the following prefixes:</p> Prefix Description SemVer <code>feat:</code> a new feature <code>MINOR</code> <code>fix:</code> a bug fix <code>PATCH</code> <code>refactor:</code> a code change that neither fixes a bug nor adds a new feature <code>PATCH</code> <code>docs:</code> a documentation-only change <code>PATCH</code> <code>chore:</code> any other change that does not affect the published module (e.g. testing) none"},{"location":"license/","title":"License","text":"<p>Apache License                            Version 2.0, January 2004                         http://www.apache.org/licenses/</p> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy] [name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"examples/","title":"Usage Examples","text":"<ul> <li>Bernoulli Bandits: a three-armed Bernoulli bandit simulation comparing epsilon-greedy, UCB1, and Thompson sampling strategies</li> </ul>"},{"location":"examples/bernoulli_bandits/","title":"Bernoulli Bandits","text":"<p>We will walk through an example using mabby to run a classic \"Bernoulli bandits\" simulation.</p> <pre><code>from mabby import BernoulliArm, Bandit, Metric, Simulation\nfrom mabby.strategies import BetaTSStrategy, EpsilonGreedyStrategy, UCB1Strategy\n</code></pre>"},{"location":"examples/bernoulli_bandits/#configuring-bandit-arms","title":"Configuring bandit arms","text":"<p>First, to set up our simulation, let us start by configuring our multi-armed bandit. We want to simulate a 3-armed bandit where the rewards of each arm follow Bernoulli distributions with <code>p</code> of 0.5, 0.6, and 0.7 respectively.</p> <pre><code>ps = [0.5, 0.6, 0.7]\n</code></pre> <p>We create a <code>BernoulliArm</code> for each arm, then create a <code>Bandit</code> using the list of arms.</p> <pre><code>arms = [BernoulliArm(p) for p in ps]\nbandit = Bandit(arms=arms)\n</code></pre> <p>Because all our arms are of the same type (i.e., their rewards follow the same type of distribution), we can also use the equivalent shorthand below to create the bandit.</p> <pre><code>bandit = BernoulliArm.bandit(p=ps)\n</code></pre>"},{"location":"examples/bernoulli_bandits/#configuring-bandit-strategies","title":"Configuring bandit strategies","text":"<p>Next, we need to configure the strategies we want to simulate on the bandit we just created. We will compare between three strategies:</p> <ul> <li>epsilon-greedy algorithm (<code>EpsilonGreedyStrategy</code>)</li> <li>upper confidence bound (UCB1) algorithm (<code>UCB1Strategy</code>)</li> <li>Thompson sampling with Beta priors (<code>BetaTSStrategy</code>)</li> </ul> <p>We create each of the strategies with the appropriate hyperparameters.</p> <pre><code>strategy_1 = EpsilonGreedyStrategy(eps=0.2)\nstrategy_2 = UCB1Strategy(alpha=0.5)\nstrategy_3 = BetaTSStrategy(general=True)\n\nstrategies = [strategy_1, strategy_2, strategy_3]\n</code></pre>"},{"location":"examples/bernoulli_bandits/#running-a-simulation","title":"Running a simulation","text":"<p>Now, we can set up a simulation and run it. We first create a <code>Simulation</code> with our bandit and strategies.</p> <pre><code>simulation = Simulation(\n    bandit=bandit, strategies=strategies, names=[\"eps-greedy\", \"ucb1\", \"thompson\"]\n)\n</code></pre> <p>Then, we run our simulation for 100 trials of 300 steps each. We also specify that we want to collect statistics on the optimality (<code>Metric.OPTIMALITY</code>) and cumulative regret (<code>Metric.CUM_REGRET</code>) for each of the strategies. Running the simulation outputs a <code>SimulationStats</code> object holding the statistics we requested.</p> <pre><code>metrics = [Metric.OPTIMALITY, Metric.CUM_REGRET]\nstats = simulation.run(trials=100, steps=300, metrics=metrics)\n</code></pre>"},{"location":"examples/bernoulli_bandits/#visualizing-simulation-statistics","title":"Visualizing simulation statistics","text":"<p>After running our simulation, we can visualize the statistics we collected by calling various plotting methods.</p> <pre><code>stats.plot_optimality()\n</code></pre> <p></p> <pre><code>stats.plot_regret(cumulative=True)\n</code></pre> <p></p>"},{"location":"reference/","title":"mabby","text":"<p>A multi-armed bandit (MAB) simulation library.</p> <p>mabby is a library for simulating multi-armed bandits (MABs), a resource-allocation problem and framework in reinforcement learning. It allows users to quickly yet flexibly define and run bandit simulations, with the ability to:</p> <ul> <li>choose from a wide range of classic bandit algorithms to use</li> <li>configure environments with custom arm spaces and rewards distributions</li> <li>collect and visualize simulation metrics like regret and optimality</li> </ul>"},{"location":"reference/#mabby.Agent","title":"<code>Agent(strategy, name=None)</code>","text":"<p>Agent in a multi-armed bandit simulation.</p> <p>An agent represents an autonomous entity in a bandit simulation. It wraps around a specified strategy and provides an interface for each part of the decision-making process, including making a choice then updating internal parameter estimates based on the observed rewards from that choice.</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>Strategy</code> <p>The bandit strategy to use.</p> required <code>name</code> <code>str | None</code> <p>An optional name for the agent.</p> <code>None</code> Source code in <code>mabby/agent.py</code> <pre><code>def __init__(self, strategy: Strategy, name: str | None = None):\n\"\"\"Initializes an agent with a given strategy.\n\n    Args:\n        strategy: The bandit strategy to use.\n        name: An optional name for the agent.\n    \"\"\"\n    self.strategy: Strategy = strategy  #: The bandit strategy to use\n    self._name = name\n    self._primed = False\n    self._choice: int | None = None\n</code></pre>"},{"location":"reference/#mabby.agent.Agent.Ns","title":"<code>Ns: NDArray[np.uint32]</code>  <code>property</code>","text":"<p>The number of times the agent has played each arm.</p> <p>The play counts are only available after the agent has been primed.</p> <p>Returns:</p> Type Description <code>NDArray[np.uint32]</code> <p>An array of the play counts of each arm.</p> <p>Raises:</p> Type Description <code>AgentUsageError</code> <p>If the agent has not been primed.</p>"},{"location":"reference/#mabby.agent.Agent.Qs","title":"<code>Qs: NDArray[np.float64]</code>  <code>property</code>","text":"<p>The agent's current estimated action values (Q-values).</p> <p>The action values are only available after the agent has been primed.</p> <p>Returns:</p> Type Description <code>NDArray[np.float64]</code> <p>An array of the action values of each arm.</p> <p>Raises:</p> Type Description <code>AgentUsageError</code> <p>If the agent has not been primed.</p>"},{"location":"reference/#mabby.agent.Agent.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the agent's string representation.</p> <p>Uses the agent's name if set. Otherwise, the string representation of the agent's strategy is used by default.</p> Source code in <code>mabby/agent.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the agent's string representation.\n\n    Uses the agent's name if set. Otherwise, the string representation of the\n    agent's strategy is used by default.\n    \"\"\"\n    if self._name is None:\n        return str(self.strategy)\n    return self._name\n</code></pre>"},{"location":"reference/#mabby.agent.Agent.choose","title":"<code>choose()</code>","text":"<p>Returns the agent's next choice based on its strategy.</p> <p>This method can only be called on a primed agent.</p> <p>Returns:</p> Type Description <code>int</code> <p>The index of the arm chosen by the agent.</p> <p>Raises:</p> Type Description <code>AgentUsageError</code> <p>If the agent has not been primed.</p> Source code in <code>mabby/agent.py</code> <pre><code>def choose(self) -&gt; int:\n\"\"\"Returns the agent's next choice based on its strategy.\n\n    This method can only be called on a primed agent.\n\n    Returns:\n        The index of the arm chosen by the agent.\n\n    Raises:\n        AgentUsageError: If the agent has not been primed.\n    \"\"\"\n    if not self._primed:\n        raise AgentUsageError(\"choose() can only be called on a primed agent\")\n    self._choice = self.strategy.choose(self._rng)\n    return self._choice\n</code></pre>"},{"location":"reference/#mabby.agent.Agent.prime","title":"<code>prime(k, steps, rng)</code>","text":"<p>Primes the agent before running a trial.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>The number of bandit arms for the agent to choose from.</p> required <code>steps</code> <code>int</code> <p>The number of steps to the simulation will be run.</p> required <code>rng</code> <code>Generator</code> <p>A random number generator.</p> required Source code in <code>mabby/agent.py</code> <pre><code>def prime(self, k: int, steps: int, rng: Generator) -&gt; None:\n\"\"\"Primes the agent before running a trial.\n\n    Args:\n        k: The number of bandit arms for the agent to choose from.\n        steps: The number of steps to the simulation will be run.\n        rng: A random number generator.\n    \"\"\"\n    self._primed = True\n    self._choice = None\n    self._rng = rng\n    self.strategy.prime(k, steps)\n</code></pre>"},{"location":"reference/#mabby.agent.Agent.update","title":"<code>update(reward)</code>","text":"<p>Updates the agent's internal parameter estimates.</p> <p>This method can only be called if the agent has previously made a choice, and an update based on that choice has not already been made.</p> <p>Parameters:</p> Name Type Description Default <code>reward</code> <code>float</code> <p>The observed reward from the agent's most recent choice.</p> required <p>Raises:</p> Type Description <code>AgentUsageError</code> <p>If the agent has not previously made a choice.</p> Source code in <code>mabby/agent.py</code> <pre><code>def update(self, reward: float) -&gt; None:\n\"\"\"Updates the agent's internal parameter estimates.\n\n    This method can only be called if the agent has previously made a choice, and\n    an update based on that choice has not already been made.\n\n    Args:\n        reward: The observed reward from the agent's most recent choice.\n\n    Raises:\n        AgentUsageError: If the agent has not previously made a choice.\n    \"\"\"\n    if self._choice is None:\n        raise AgentUsageError(\"update() can only be called after choose()\")\n    self.strategy.update(self._choice, reward, self._rng)\n    self._choice = None\n</code></pre>"},{"location":"reference/#mabby.Arm","title":"<code>Arm(**kwargs)</code>","text":"<p>         Bases: <code>ABC</code>, <code>EnforceOverrides</code></p> <p>Base class for a bandit arm implementing a reward distribution.</p> <p>An arm represents one of the decision choices available to the agent in a bandit problem. It has a hidden reward distribution and can be played by the agent to generate observable rewards.</p> Source code in <code>mabby/arms.py</code> <pre><code>@abstractmethod\ndef __init__(self, **kwargs: float):\n\"\"\"Initializes an arm.\"\"\"\n</code></pre>"},{"location":"reference/#mabby.arms.Arm.mean","title":"<code>mean: float</code>  <code>property</code> <code>abstractmethod</code>","text":"<p>The mean reward of the arm.</p> <p>Returns:</p> Type Description <code>float</code> <p>The computed mean of the arm's reward distribution.</p>"},{"location":"reference/#mabby.arms.Arm.__repr__","title":"<code>__repr__()</code>  <code>abstractmethod</code>","text":"<p>Returns the string representation of the arm.</p> Source code in <code>mabby/arms.py</code> <pre><code>@abstractmethod\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the arm.\"\"\"\n</code></pre>"},{"location":"reference/#mabby.arms.Arm.bandit","title":"<code>bandit(rng=None, seed=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a bandit with arms of the same reward distribution type.</p> <p>Parameters:</p> Name Type Description Default <code>rng</code> <code>Generator | None</code> <p>A random number generator.</p> <code>None</code> <code>seed</code> <code>int | None</code> <p>A seed for random number generation if <code>rng</code> is not provided.</p> <code>None</code> <code>**kwargs</code> <code>list[float]</code> <p>A dictionary where keys are arm parameter names and values are lists of parameter values for each arm.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Bandit</code> <p>A bandit with the specified arms.</p> Source code in <code>mabby/arms.py</code> <pre><code>@classmethod\ndef bandit(\n    cls,\n    rng: Generator | None = None,\n    seed: int | None = None,\n    **kwargs: list[float],\n) -&gt; Bandit:\n\"\"\"Creates a bandit with arms of the same reward distribution type.\n\n    Args:\n        rng: A random number generator.\n        seed: A seed for random number generation if ``rng`` is not provided.\n        **kwargs: A dictionary where keys are arm parameter names and values are\n            lists of parameter values for each arm.\n\n    Returns:\n        A bandit with the specified arms.\n    \"\"\"\n    params_dicts = [dict(zip(kwargs, t)) for t in zip(*kwargs.values())]\n    if len(params_dicts) == 0:\n        raise ValueError(\"insufficient parameters to create an arm\")\n    return Bandit([cls(**params) for params in params_dicts], rng, seed)\n</code></pre>"},{"location":"reference/#mabby.arms.Arm.play","title":"<code>play(rng)</code>  <code>abstractmethod</code>","text":"<p>Plays the arm and samples a reward.</p> <p>Parameters:</p> Name Type Description Default <code>rng</code> <code>Generator</code> <p>A random number generator.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The sampled reward from the arm's reward distribution.</p> Source code in <code>mabby/arms.py</code> <pre><code>@abstractmethod\ndef play(self, rng: Generator) -&gt; float:\n\"\"\"Plays the arm and samples a reward.\n\n    Args:\n        rng: A random number generator.\n\n    Returns:\n        The sampled reward from the arm's reward distribution.\n    \"\"\"\n</code></pre>"},{"location":"reference/#mabby.Bandit","title":"<code>Bandit(arms, rng=None, seed=None)</code>","text":"<p>Multi-armed bandit with one or more arms.</p> <p>This class wraps around a list of arms, each of which has a reward distribution. It provides an interface for interacting with the arms, such as playing a specific arm, querying for the optimal arm, and computing regret from a given choice.</p> <p>Parameters:</p> Name Type Description Default <code>arms</code> <code>list[Arm]</code> <p>A list of arms for the bandit.</p> required <code>rng</code> <code>Generator | None</code> <p>A random number generator.</p> <code>None</code> <code>seed</code> <code>int | None</code> <p>A seed for random number generation if <code>rng</code> is not provided.</p> <code>None</code> Source code in <code>mabby/bandit.py</code> <pre><code>def __init__(\n    self, arms: list[Arm], rng: Generator | None = None, seed: int | None = None\n):\n\"\"\"Initializes a bandit with a given set of arms.\n\n    Args:\n        arms: A list of arms for the bandit.\n        rng: A random number generator.\n        seed: A seed for random number generation if ``rng`` is not provided.\n    \"\"\"\n    self._arms = arms\n    self._rng = rng if rng else np.random.default_rng(seed)\n</code></pre>"},{"location":"reference/#mabby.bandit.Bandit.means","title":"<code>means: list[float]</code>  <code>property</code>","text":"<p>The means of the arms.</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>An array of the means of each arm.</p>"},{"location":"reference/#mabby.bandit.Bandit.__getitem__","title":"<code>__getitem__(i)</code>","text":"<p>Returns an arm by index.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int</code> <p>The index of the arm to get.</p> required <p>Returns:</p> Type Description <code>Arm</code> <p>The arm at the given index.</p> Source code in <code>mabby/bandit.py</code> <pre><code>def __getitem__(self, i: int) -&gt; Arm:\n\"\"\"Returns an arm by index.\n\n    Args:\n        i: The index of the arm to get.\n\n    Returns:\n        The arm at the given index.\n    \"\"\"\n    return self._arms[i]\n</code></pre>"},{"location":"reference/#mabby.bandit.Bandit.__iter__","title":"<code>__iter__()</code>","text":"<p>Returns an iterator over the bandit's arms.</p> Source code in <code>mabby/bandit.py</code> <pre><code>def __iter__(self) -&gt; Iterable[Arm]:\n\"\"\"Returns an iterator over the bandit's arms.\"\"\"\n    return iter(self._arms)\n</code></pre>"},{"location":"reference/#mabby.bandit.Bandit.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of arms.</p> Source code in <code>mabby/bandit.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Returns the number of arms.\"\"\"\n    return len(self._arms)\n</code></pre>"},{"location":"reference/#mabby.bandit.Bandit.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns a string representation of the bandit.</p> Source code in <code>mabby/bandit.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns a string representation of the bandit.\"\"\"\n    return repr(self._arms)\n</code></pre>"},{"location":"reference/#mabby.bandit.Bandit.best_arm","title":"<code>best_arm()</code>","text":"<p>Returns the index of the optimal arm.</p> <p>The optimal arm is the arm with the greatest expected reward. If there are multiple arms with equal expected rewards, a random one is chosen.</p> <p>Returns:</p> Type Description <code>int</code> <p>The index of the optimal arm.</p> Source code in <code>mabby/bandit.py</code> <pre><code>def best_arm(self) -&gt; int:\n\"\"\"Returns the index of the optimal arm.\n\n    The optimal arm is the arm with the greatest expected reward. If there are\n    multiple arms with equal expected rewards, a random one is chosen.\n\n    Returns:\n        The index of the optimal arm.\n    \"\"\"\n    return random_argmax(self.means, rng=self._rng)\n</code></pre>"},{"location":"reference/#mabby.bandit.Bandit.is_opt","title":"<code>is_opt(choice)</code>","text":"<p>Returns the optimality of a given choice.</p> <p>Parameters:</p> Name Type Description Default <code>choice</code> <code>int</code> <p>The index of the chosen arm.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the arm has the greatest expected reward, <code>False</code> otherwise.</p> Source code in <code>mabby/bandit.py</code> <pre><code>def is_opt(self, choice: int) -&gt; bool:\n\"\"\"Returns the optimality of a given choice.\n\n    Args:\n        choice: The index of the chosen arm.\n\n    Returns:\n        ``True`` if the arm has the greatest expected reward, ``False`` otherwise.\n    \"\"\"\n    return np.max(self.means) == self._arms[choice].mean\n</code></pre>"},{"location":"reference/#mabby.bandit.Bandit.play","title":"<code>play(i)</code>","text":"<p>Plays an arm by index.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int</code> <p>The index of the arm to play.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The reward from playing the arm.</p> Source code in <code>mabby/bandit.py</code> <pre><code>def play(self, i: int) -&gt; float:\n\"\"\"Plays an arm by index.\n\n    Args:\n        i: The index of the arm to play.\n\n    Returns:\n        The reward from playing the arm.\n    \"\"\"\n    return self[i].play(self._rng)\n</code></pre>"},{"location":"reference/#mabby.bandit.Bandit.regret","title":"<code>regret(choice)</code>","text":"<p>Returns the regret from a given choice.</p> <p>The regret is computed as the difference between the expected reward from the optimal arm and the expected reward from the chosen arm.</p> <p>Parameters:</p> Name Type Description Default <code>choice</code> <code>int</code> <p>The index of the chosen arm.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The computed regret value.</p> Source code in <code>mabby/bandit.py</code> <pre><code>def regret(self, choice: int) -&gt; float:\n\"\"\"Returns the regret from a given choice.\n\n    The regret is computed as the difference between the expected reward from the\n    optimal arm and the expected reward from the chosen arm.\n\n    Args:\n        choice: The index of the chosen arm.\n\n    Returns:\n        The computed regret value.\n    \"\"\"\n    return np.max(self.means) - self._arms[choice].mean\n</code></pre>"},{"location":"reference/#mabby.BernoulliArm","title":"<code>BernoulliArm(p)</code>","text":"<p>         Bases: <code>Arm</code></p> <p>Bandit arm with a Bernoulli reward distribution.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>float</code> <p>Parameter of the Bernoulli distribution.</p> required Source code in <code>mabby/arms.py</code> <pre><code>def __init__(self, p: float):\n\"\"\"Initializes a Bernoulli arm.\n\n    Args:\n        p: Parameter of the Bernoulli distribution.\n    \"\"\"\n    if p &lt; 0 or p &gt; 1:\n        raise ValueError(\n            f\"float {str(p)} is not a valid probability for Bernoulli distribution\"\n        )\n\n    self.p: float = p  #: Parameter of the Bernoulli distribution\n</code></pre>"},{"location":"reference/#mabby.GaussianArm","title":"<code>GaussianArm(loc, scale)</code>","text":"<p>         Bases: <code>Arm</code></p> <p>Bandit arm with a Gaussian reward distribution.</p> <p>Parameters:</p> Name Type Description Default <code>loc</code> <code>float</code> <p>Mean (\"center\") of the Gaussian distribution.</p> required <code>scale</code> <code>float</code> <p>Standard deviation of the Gaussian distribution.</p> required Source code in <code>mabby/arms.py</code> <pre><code>def __init__(self, loc: float, scale: float):\n\"\"\"Initializes a Gaussian arm.\n\n    Args:\n        loc: Mean (\"center\") of the Gaussian distribution.\n        scale: Standard deviation of the Gaussian distribution.\n    \"\"\"\n    if scale &lt; 0:\n        raise ValueError(\n            f\"float {str(scale)} is not a valid scale for Gaussian distribution\"\n        )\n\n    self.loc: float = loc  #: Mean (\"center\") of the Gaussian distribution\n    self.scale: float = scale  #: Standard deviation of the Gaussian distribution\n</code></pre>"},{"location":"reference/#mabby.Metric","title":"<code>Metric(label, base=None, transform=None)</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Enum for metrics that simulations can track.</p> <p>Metrics can be derived from other metrics through specifying a <code>base</code> metric and a <code>transform</code> function. This is useful for things like defining cumulative versions of an existing metric, where the transformed values can be computed \"lazily\" instead of being redundantly stored.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Verbose name of the metric (title case)</p> required <code>base</code> <code>str | None</code> <p>Name of the base metric</p> <code>None</code> <code>transform</code> <code>Callable[[NDArray[np.float64]], NDArray[np.float64]] | None</code> <p>Transformation function from the base metric</p> <code>None</code> Source code in <code>mabby/stats.py</code> <pre><code>def __init__(\n    self,\n    label: str,\n    base: str | None = None,\n    transform: Callable[[NDArray[np.float64]], NDArray[np.float64]] | None = None,\n):\n\"\"\"Initializes a metric.\n\n    Metrics can be derived from other metrics through specifying a ``base`` metric\n    and a ``transform`` function. This is useful for things like defining cumulative\n    versions of an existing metric, where the transformed values can be computed\n    \"lazily\" instead of being redundantly stored.\n\n    Args:\n        label: Verbose name of the metric (title case)\n        base: Name of the base metric\n        transform: Transformation function from the base metric\n    \"\"\"\n    self.__class__.__MAPPING__[self._name_] = self\n    self._label = label\n    self._mapping: MetricMapping | None = (\n        MetricMapping(base=self.__class__.__MAPPING__[base], transform=transform)\n        if base and transform\n        else None\n    )\n</code></pre>"},{"location":"reference/#mabby.stats.Metric.base","title":"<code>base: Metric</code>  <code>property</code>","text":"<p>The base metric that the metric is transformed from.</p> <p>If the metric is already a base metric, the metric itself is returned.</p>"},{"location":"reference/#mabby.stats.Metric.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the verbose name of the metric.</p> Source code in <code>mabby/stats.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the verbose name of the metric.\"\"\"\n    return self._label\n</code></pre>"},{"location":"reference/#mabby.stats.Metric.is_base","title":"<code>is_base()</code>","text":"<p>Returns whether the metric is a base metric.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the metric is a base metric, <code>False</code> otherwise.</p> Source code in <code>mabby/stats.py</code> <pre><code>def is_base(self) -&gt; bool:\n\"\"\"Returns whether the metric is a base metric.\n\n    Returns:\n        ``True`` if the metric is a base metric, ``False`` otherwise.\n    \"\"\"\n    return self._mapping is None\n</code></pre>"},{"location":"reference/#mabby.stats.Metric.map_to_base","title":"<code>map_to_base(metrics)</code>  <code>classmethod</code>","text":"<p>Traces all metrics back to their base metrics.</p> <p>Parameters:</p> Name Type Description Default <code>metrics</code> <code>Iterable[Metric]</code> <p>A collection of metrics.</p> required <p>Returns:</p> Type Description <code>Iterable[Metric]</code> <p>A set containing the base metrics of all the input metrics.</p> Source code in <code>mabby/stats.py</code> <pre><code>@classmethod\ndef map_to_base(cls, metrics: Iterable[Metric]) -&gt; Iterable[Metric]:\n\"\"\"Traces all metrics back to their base metrics.\n\n    Args:\n        metrics: A collection of metrics.\n\n    Returns:\n        A set containing the base metrics of all the input metrics.\n    \"\"\"\n    return set(m.base for m in metrics)\n</code></pre>"},{"location":"reference/#mabby.stats.Metric.transform","title":"<code>transform(values)</code>","text":"<p>Transforms values from the base metric.</p> <p>If the metric is already a base metric, the input values are returned.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>NDArray[np.float64]</code> <p>An array of input values for the base metric.</p> required <p>Returns:</p> Type Description <code>NDArray[np.float64]</code> <p>An array of transformed values for the metric.</p> Source code in <code>mabby/stats.py</code> <pre><code>def transform(self, values: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n\"\"\"Transforms values from the base metric.\n\n    If the metric is already a base metric, the input values are returned.\n\n    Args:\n        values: An array of input values for the base metric.\n\n    Returns:\n        An array of transformed values for the metric.\n    \"\"\"\n    if self._mapping is not None:\n        return self._mapping.transform(values)\n    return values\n</code></pre>"},{"location":"reference/#mabby.Simulation","title":"<code>Simulation(bandit, agents=None, strategies=None, names=None, rng=None, seed=None)</code>","text":"<p>Simulation of a multi-armed bandit problem.</p> <p>A simulation consists of multiple trials of one or more bandit strategies run on a configured multi-armed bandit.</p> <p>One of <code>agents</code> or <code>strategies</code> must be supplied. If <code>agents</code> is supplied, <code>strategies</code> and <code>names</code> are ignored. Otherwise, an <code>agent</code> is created for each <code>strategy</code> and given a name from <code>names</code> if available.</p> <p>Parameters:</p> Name Type Description Default <code>bandit</code> <code>Bandit</code> <p>A configured multi-armed bandit to simulate on.</p> required <code>agents</code> <code>Iterable[Agent] | None</code> <p>A list of agents to simulate.</p> <code>None</code> <code>strategies</code> <code>Iterable[Strategy] | None</code> <p>A list of strategies to simulate.</p> <code>None</code> <code>names</code> <code>Iterable[str] | None</code> <p>A list of names for agents.</p> <code>None</code> <code>rng</code> <code>Generator | None</code> <p>A random number generator.</p> <code>None</code> <code>seed</code> <code>int | None</code> <p>A seed for random number generation if <code>rng</code> is not provided.</p> <code>None</code> <p>Raises:</p> Type Description <code>SimulationUsageError</code> <p>If neither <code>agents</code> nor <code>strategies</code> are supplied.</p> Source code in <code>mabby/simulation.py</code> <pre><code>def __init__(\n    self,\n    bandit: Bandit,\n    agents: Iterable[Agent] | None = None,\n    strategies: Iterable[Strategy] | None = None,\n    names: Iterable[str] | None = None,\n    rng: Generator | None = None,\n    seed: int | None = None,\n):\n\"\"\"Initializes a simulation.\n\n    One of ``agents`` or ``strategies`` must be supplied. If ``agents`` is supplied,\n    ``strategies`` and ``names`` are ignored. Otherwise, an ``agent`` is created for\n    each ``strategy`` and given a name from ``names`` if available.\n\n    Args:\n        bandit: A configured multi-armed bandit to simulate on.\n        agents: A list of agents to simulate.\n        strategies: A list of strategies to simulate.\n        names: A list of names for agents.\n        rng: A random number generator.\n        seed: A seed for random number generation if ``rng`` is not provided.\n\n    Raises:\n        SimulationUsageError: If neither ``agents`` nor ``strategies`` are supplied.\n    \"\"\"\n    self.agents = self._create_agents(agents, strategies, names)\n    if len(list(self.agents)) == 0:\n        raise ValueError(\"no strategies or agents were supplied\")\n    self.bandit = bandit\n    if len(self.bandit) == 0:\n        raise ValueError(\"bandit cannot be empty\")\n    self._rng = rng if rng else np.random.default_rng(seed)\n</code></pre>"},{"location":"reference/#mabby.simulation.Simulation.run","title":"<code>run(trials, steps, metrics=None)</code>","text":"<p>Runs a simulation.</p> <p>In a simulation run, each agent or strategy is run for the specified number of trials, and each trial is run for the given number of steps.</p> <p>If <code>metrics</code> is not specified, all available metrics are tracked by default.</p> <p>Parameters:</p> Name Type Description Default <code>trials</code> <code>int</code> <p>The number of trials in the simulation.</p> required <code>steps</code> <code>int</code> <p>The number of steps in a trial.</p> required <code>metrics</code> <code>Iterable[Metric] | None</code> <p>A list of metrics to collect.</p> <code>None</code> <p>Returns:</p> Type Description <code>SimulationStats</code> <p>A <code>SimulationStats</code> object with the results of the simulation.</p> Source code in <code>mabby/simulation.py</code> <pre><code>def run(\n    self, trials: int, steps: int, metrics: Iterable[Metric] | None = None\n) -&gt; SimulationStats:\n\"\"\"Runs a simulation.\n\n    In a simulation run, each agent or strategy is run for the specified number of\n    trials, and each trial is run for the given number of steps.\n\n    If ``metrics`` is not specified, all available metrics are tracked by default.\n\n    Args:\n        trials: The number of trials in the simulation.\n        steps: The number of steps in a trial.\n        metrics: A list of metrics to collect.\n\n    Returns:\n        A ``SimulationStats`` object with the results of the simulation.\n    \"\"\"\n    sim_stats = SimulationStats(simulation=self)\n    for agent in self.agents:\n        agent_stats = self._run_trials_for_agent(agent, trials, steps, metrics)\n        sim_stats.add(agent_stats)\n    return sim_stats\n</code></pre>"},{"location":"reference/#mabby.SimulationStats","title":"<code>SimulationStats(simulation)</code>","text":"<p>Statistics for a multi-armed bandit simulation.</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>The simulation to track.</p> required Source code in <code>mabby/stats.py</code> <pre><code>def __init__(self, simulation: Simulation):\n\"\"\"Initializes simulation statistics.\n\n    Args:\n        simulation: The simulation to track.\n    \"\"\"\n    self._simulation: Simulation = simulation\n    self._stats_dict: dict[Agent, AgentStats] = {}\n</code></pre>"},{"location":"reference/#mabby.stats.SimulationStats.__contains__","title":"<code>__contains__(agent)</code>","text":"<p>Returns if an agent's statistics are present.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if an agent's statistics are present, <code>False</code> otherwise.</p> Source code in <code>mabby/stats.py</code> <pre><code>def __contains__(self, agent: Agent) -&gt; bool:\n\"\"\"Returns if an agent's statistics are present.\n\n    Returns:\n        ``True`` if an agent's statistics are present, ``False`` otherwise.\n    \"\"\"\n    return agent in self._stats_dict\n</code></pre>"},{"location":"reference/#mabby.stats.SimulationStats.__getitem__","title":"<code>__getitem__(agent)</code>","text":"<p>Gets statistics for an agent.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>The agent to get the statistics of.</p> required <p>Returns:</p> Type Description <code>AgentStats</code> <p>The statistics of the agent.</p> Source code in <code>mabby/stats.py</code> <pre><code>def __getitem__(self, agent: Agent) -&gt; AgentStats:\n\"\"\"Gets statistics for an agent.\n\n    Args:\n        agent: The agent to get the statistics of.\n\n    Returns:\n        The statistics of the agent.\n    \"\"\"\n    return self._stats_dict[agent]\n</code></pre>"},{"location":"reference/#mabby.stats.SimulationStats.__setitem__","title":"<code>__setitem__(agent, agent_stats)</code>","text":"<p>Sets the statistics for an agent.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>The agent to set the statistics of.</p> required <code>agent_stats</code> <code>AgentStats</code> <p>The agent statistics to set.</p> required Source code in <code>mabby/stats.py</code> <pre><code>def __setitem__(self, agent: Agent, agent_stats: AgentStats) -&gt; None:\n\"\"\"Sets the statistics for an agent.\n\n    Args:\n        agent: The agent to set the statistics of.\n        agent_stats: The agent statistics to set.\n    \"\"\"\n    if agent != agent_stats.agent:\n        raise StatsUsageError(\"agents specified in key and value don't match\")\n    self._stats_dict[agent] = agent_stats\n</code></pre>"},{"location":"reference/#mabby.stats.SimulationStats.add","title":"<code>add(agent_stats)</code>","text":"<p>Adds statistics for an agent.</p> <p>Parameters:</p> Name Type Description Default <code>agent_stats</code> <code>AgentStats</code> <p>The agent statistics to add.</p> required Source code in <code>mabby/stats.py</code> <pre><code>def add(self, agent_stats: AgentStats) -&gt; None:\n\"\"\"Adds statistics for an agent.\n\n    Args:\n        agent_stats: The agent statistics to add.\n    \"\"\"\n    self._stats_dict[agent_stats.agent] = agent_stats\n</code></pre>"},{"location":"reference/#mabby.stats.SimulationStats.plot","title":"<code>plot(metric)</code>","text":"<p>Generates a plot for a simulation metric.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>Metric</code> <p>The metric to plot.</p> required Source code in <code>mabby/stats.py</code> <pre><code>def plot(self, metric: Metric) -&gt; None:\n\"\"\"Generates a plot for a simulation metric.\n\n    Args:\n        metric: The metric to plot.\n    \"\"\"\n    for agent, agent_stats in self._stats_dict.items():\n        plt.plot(agent_stats[metric], label=str(agent))\n    plt.legend()\n    plt.show()\n</code></pre>"},{"location":"reference/#mabby.stats.SimulationStats.plot_optimality","title":"<code>plot_optimality()</code>","text":"<p>Generates a plot for the optimality metric.</p> Source code in <code>mabby/stats.py</code> <pre><code>def plot_optimality(self) -&gt; None:\n\"\"\"Generates a plot for the optimality metric.\"\"\"\n    self.plot(metric=Metric.OPTIMALITY)\n</code></pre>"},{"location":"reference/#mabby.stats.SimulationStats.plot_regret","title":"<code>plot_regret(cumulative=True)</code>","text":"<p>Generates a plot for the regret or cumulative regret metrics.</p> <p>Parameters:</p> Name Type Description Default <code>cumulative</code> <code>bool</code> <p>Whether to use the cumulative regret.</p> <code>True</code> Source code in <code>mabby/stats.py</code> <pre><code>def plot_regret(self, cumulative: bool = True) -&gt; None:\n\"\"\"Generates a plot for the regret or cumulative regret metrics.\n\n    Args:\n        cumulative: Whether to use the cumulative regret.\n    \"\"\"\n    self.plot(metric=Metric.CUM_REGRET if cumulative else Metric.REGRET)\n</code></pre>"},{"location":"reference/#mabby.stats.SimulationStats.plot_rewards","title":"<code>plot_rewards(cumulative=True)</code>","text":"<p>Generates a plot for the rewards or cumulative rewards metrics.</p> <p>Parameters:</p> Name Type Description Default <code>cumulative</code> <code>bool</code> <p>Whether to use the cumulative rewards.</p> <code>True</code> Source code in <code>mabby/stats.py</code> <pre><code>def plot_rewards(self, cumulative: bool = True) -&gt; None:\n\"\"\"Generates a plot for the rewards or cumulative rewards metrics.\n\n    Args:\n        cumulative: Whether to use the cumulative rewards.\n    \"\"\"\n    self.plot(metric=Metric.CUM_REWARDS if cumulative else Metric.REWARDS)\n</code></pre>"},{"location":"reference/#mabby.Strategy","title":"<code>Strategy()</code>","text":"<p>         Bases: <code>ABC</code>, <code>EnforceOverrides</code></p> <p>Base class for a bandit strategy.</p> <p>A strategy provides the computational logic for choosing which bandit arms to play and updating parameter estimates.</p> Source code in <code>mabby/strategies/strategy.py</code> <pre><code>@abstractmethod\ndef __init__(self) -&gt; None:\n\"\"\"Initializes a bandit strategy.\"\"\"\n</code></pre>"},{"location":"reference/#mabby.strategies.strategy.Strategy.Ns","title":"<code>Ns: NDArray[np.uint32]</code>  <code>property</code> <code>abstractmethod</code>","text":"<p>The number of times each arm has been played.</p>"},{"location":"reference/#mabby.strategies.strategy.Strategy.Qs","title":"<code>Qs: NDArray[np.float64]</code>  <code>property</code> <code>abstractmethod</code>","text":"<p>The current estimated action values for each arm.</p>"},{"location":"reference/#mabby.strategies.strategy.Strategy.__repr__","title":"<code>__repr__()</code>  <code>abstractmethod</code>","text":"<p>Returns a string representation of the strategy.</p> Source code in <code>mabby/strategies/strategy.py</code> <pre><code>@abstractmethod\ndef __repr__(self) -&gt; str:\n\"\"\"Returns a string representation of the strategy.\"\"\"\n</code></pre>"},{"location":"reference/#mabby.strategies.strategy.Strategy.agent","title":"<code>agent(**kwargs)</code>","text":"<p>Creates an agent following the strategy.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>str</code> <p>Parameters for initializing the agent (see <code>Agent</code>)</p> <code>{}</code> <p>Returns:</p> Type Description <code>Agent</code> <p>The created agent with the strategy.</p> Source code in <code>mabby/strategies/strategy.py</code> <pre><code>def agent(self, **kwargs: str) -&gt; Agent:\n\"\"\"Creates an agent following the strategy.\n\n    Args:\n        **kwargs: Parameters for initializing the agent (see\n            [`Agent`][mabby.agent.Agent])\n\n    Returns:\n        The created agent with the strategy.\n    \"\"\"\n    return Agent(strategy=self, **kwargs)\n</code></pre>"},{"location":"reference/#mabby.strategies.strategy.Strategy.choose","title":"<code>choose(rng)</code>  <code>abstractmethod</code>","text":"<p>Returns the next arm to play.</p> <p>Parameters:</p> Name Type Description Default <code>rng</code> <code>Generator</code> <p>A random number generator.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The index of the arm to play.</p> Source code in <code>mabby/strategies/strategy.py</code> <pre><code>@abstractmethod\ndef choose(self, rng: Generator) -&gt; int:\n\"\"\"Returns the next arm to play.\n\n    Args:\n        rng: A random number generator.\n\n    Returns:\n        The index of the arm to play.\n    \"\"\"\n</code></pre>"},{"location":"reference/#mabby.strategies.strategy.Strategy.prime","title":"<code>prime(k, steps)</code>  <code>abstractmethod</code>","text":"<p>Primes the strategy before running a trial.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>The number of bandit arms to choose from.</p> required <code>steps</code> <code>int</code> <p>The number of steps to the simulation will be run.</p> required Source code in <code>mabby/strategies/strategy.py</code> <pre><code>@abstractmethod\ndef prime(self, k: int, steps: int) -&gt; None:\n\"\"\"Primes the strategy before running a trial.\n\n    Args:\n        k: The number of bandit arms to choose from.\n        steps: The number of steps to the simulation will be run.\n    \"\"\"\n</code></pre>"},{"location":"reference/#mabby.strategies.strategy.Strategy.update","title":"<code>update(choice, reward, rng=None)</code>  <code>abstractmethod</code>","text":"<p>Updates internal parameter estimates based on reward observation.</p> <p>Parameters:</p> Name Type Description Default <code>choice</code> <code>int</code> <p>The most recent choice made.</p> required <code>reward</code> <code>float</code> <p>The observed reward from the agent's most recent choice.</p> required <code>rng</code> <code>Generator | None</code> <p>A random number generator.</p> <code>None</code> Source code in <code>mabby/strategies/strategy.py</code> <pre><code>@abstractmethod\ndef update(self, choice: int, reward: float, rng: Generator | None = None) -&gt; None:\n\"\"\"Updates internal parameter estimates based on reward observation.\n\n    Args:\n        choice: The most recent choice made.\n        reward: The observed reward from the agent's most recent choice.\n        rng: A random number generator.\n    \"\"\"\n</code></pre>"},{"location":"reference/agent/","title":"agent","text":"<p>Provides <code>Agent</code> class for bandit simulations.</p>"},{"location":"reference/agent/#mabby.agent.Agent","title":"<code>Agent(strategy, name=None)</code>","text":"<p>Agent in a multi-armed bandit simulation.</p> <p>An agent represents an autonomous entity in a bandit simulation. It wraps around a specified strategy and provides an interface for each part of the decision-making process, including making a choice then updating internal parameter estimates based on the observed rewards from that choice.</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>Strategy</code> <p>The bandit strategy to use.</p> required <code>name</code> <code>str | None</code> <p>An optional name for the agent.</p> <code>None</code> Source code in <code>mabby/agent.py</code> <pre><code>def __init__(self, strategy: Strategy, name: str | None = None):\n\"\"\"Initializes an agent with a given strategy.\n\n    Args:\n        strategy: The bandit strategy to use.\n        name: An optional name for the agent.\n    \"\"\"\n    self.strategy: Strategy = strategy  #: The bandit strategy to use\n    self._name = name\n    self._primed = False\n    self._choice: int | None = None\n</code></pre>"},{"location":"reference/agent/#mabby.agent.Agent.Ns","title":"<code>Ns: NDArray[np.uint32]</code>  <code>property</code>","text":"<p>The number of times the agent has played each arm.</p> <p>The play counts are only available after the agent has been primed.</p> <p>Returns:</p> Type Description <code>NDArray[np.uint32]</code> <p>An array of the play counts of each arm.</p> <p>Raises:</p> Type Description <code>AgentUsageError</code> <p>If the agent has not been primed.</p>"},{"location":"reference/agent/#mabby.agent.Agent.Qs","title":"<code>Qs: NDArray[np.float64]</code>  <code>property</code>","text":"<p>The agent's current estimated action values (Q-values).</p> <p>The action values are only available after the agent has been primed.</p> <p>Returns:</p> Type Description <code>NDArray[np.float64]</code> <p>An array of the action values of each arm.</p> <p>Raises:</p> Type Description <code>AgentUsageError</code> <p>If the agent has not been primed.</p>"},{"location":"reference/agent/#mabby.agent.Agent.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the agent's string representation.</p> <p>Uses the agent's name if set. Otherwise, the string representation of the agent's strategy is used by default.</p> Source code in <code>mabby/agent.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the agent's string representation.\n\n    Uses the agent's name if set. Otherwise, the string representation of the\n    agent's strategy is used by default.\n    \"\"\"\n    if self._name is None:\n        return str(self.strategy)\n    return self._name\n</code></pre>"},{"location":"reference/agent/#mabby.agent.Agent.choose","title":"<code>choose()</code>","text":"<p>Returns the agent's next choice based on its strategy.</p> <p>This method can only be called on a primed agent.</p> <p>Returns:</p> Type Description <code>int</code> <p>The index of the arm chosen by the agent.</p> <p>Raises:</p> Type Description <code>AgentUsageError</code> <p>If the agent has not been primed.</p> Source code in <code>mabby/agent.py</code> <pre><code>def choose(self) -&gt; int:\n\"\"\"Returns the agent's next choice based on its strategy.\n\n    This method can only be called on a primed agent.\n\n    Returns:\n        The index of the arm chosen by the agent.\n\n    Raises:\n        AgentUsageError: If the agent has not been primed.\n    \"\"\"\n    if not self._primed:\n        raise AgentUsageError(\"choose() can only be called on a primed agent\")\n    self._choice = self.strategy.choose(self._rng)\n    return self._choice\n</code></pre>"},{"location":"reference/agent/#mabby.agent.Agent.prime","title":"<code>prime(k, steps, rng)</code>","text":"<p>Primes the agent before running a trial.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>The number of bandit arms for the agent to choose from.</p> required <code>steps</code> <code>int</code> <p>The number of steps to the simulation will be run.</p> required <code>rng</code> <code>Generator</code> <p>A random number generator.</p> required Source code in <code>mabby/agent.py</code> <pre><code>def prime(self, k: int, steps: int, rng: Generator) -&gt; None:\n\"\"\"Primes the agent before running a trial.\n\n    Args:\n        k: The number of bandit arms for the agent to choose from.\n        steps: The number of steps to the simulation will be run.\n        rng: A random number generator.\n    \"\"\"\n    self._primed = True\n    self._choice = None\n    self._rng = rng\n    self.strategy.prime(k, steps)\n</code></pre>"},{"location":"reference/agent/#mabby.agent.Agent.update","title":"<code>update(reward)</code>","text":"<p>Updates the agent's internal parameter estimates.</p> <p>This method can only be called if the agent has previously made a choice, and an update based on that choice has not already been made.</p> <p>Parameters:</p> Name Type Description Default <code>reward</code> <code>float</code> <p>The observed reward from the agent's most recent choice.</p> required <p>Raises:</p> Type Description <code>AgentUsageError</code> <p>If the agent has not previously made a choice.</p> Source code in <code>mabby/agent.py</code> <pre><code>def update(self, reward: float) -&gt; None:\n\"\"\"Updates the agent's internal parameter estimates.\n\n    This method can only be called if the agent has previously made a choice, and\n    an update based on that choice has not already been made.\n\n    Args:\n        reward: The observed reward from the agent's most recent choice.\n\n    Raises:\n        AgentUsageError: If the agent has not previously made a choice.\n    \"\"\"\n    if self._choice is None:\n        raise AgentUsageError(\"update() can only be called after choose()\")\n    self.strategy.update(self._choice, reward, self._rng)\n    self._choice = None\n</code></pre>"},{"location":"reference/arms/","title":"arms","text":"<p>Provides <code>Arm</code> base class with some common reward distributions.</p>"},{"location":"reference/arms/#mabby.arms.Arm","title":"<code>Arm(**kwargs)</code>","text":"<p>         Bases: <code>ABC</code>, <code>EnforceOverrides</code></p> <p>Base class for a bandit arm implementing a reward distribution.</p> <p>An arm represents one of the decision choices available to the agent in a bandit problem. It has a hidden reward distribution and can be played by the agent to generate observable rewards.</p> Source code in <code>mabby/arms.py</code> <pre><code>@abstractmethod\ndef __init__(self, **kwargs: float):\n\"\"\"Initializes an arm.\"\"\"\n</code></pre>"},{"location":"reference/arms/#mabby.arms.Arm.mean","title":"<code>mean: float</code>  <code>property</code> <code>abstractmethod</code>","text":"<p>The mean reward of the arm.</p> <p>Returns:</p> Type Description <code>float</code> <p>The computed mean of the arm's reward distribution.</p>"},{"location":"reference/arms/#mabby.arms.Arm.__repr__","title":"<code>__repr__()</code>  <code>abstractmethod</code>","text":"<p>Returns the string representation of the arm.</p> Source code in <code>mabby/arms.py</code> <pre><code>@abstractmethod\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the arm.\"\"\"\n</code></pre>"},{"location":"reference/arms/#mabby.arms.Arm.bandit","title":"<code>bandit(rng=None, seed=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a bandit with arms of the same reward distribution type.</p> <p>Parameters:</p> Name Type Description Default <code>rng</code> <code>Generator | None</code> <p>A random number generator.</p> <code>None</code> <code>seed</code> <code>int | None</code> <p>A seed for random number generation if <code>rng</code> is not provided.</p> <code>None</code> <code>**kwargs</code> <code>list[float]</code> <p>A dictionary where keys are arm parameter names and values are lists of parameter values for each arm.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Bandit</code> <p>A bandit with the specified arms.</p> Source code in <code>mabby/arms.py</code> <pre><code>@classmethod\ndef bandit(\n    cls,\n    rng: Generator | None = None,\n    seed: int | None = None,\n    **kwargs: list[float],\n) -&gt; Bandit:\n\"\"\"Creates a bandit with arms of the same reward distribution type.\n\n    Args:\n        rng: A random number generator.\n        seed: A seed for random number generation if ``rng`` is not provided.\n        **kwargs: A dictionary where keys are arm parameter names and values are\n            lists of parameter values for each arm.\n\n    Returns:\n        A bandit with the specified arms.\n    \"\"\"\n    params_dicts = [dict(zip(kwargs, t)) for t in zip(*kwargs.values())]\n    if len(params_dicts) == 0:\n        raise ValueError(\"insufficient parameters to create an arm\")\n    return Bandit([cls(**params) for params in params_dicts], rng, seed)\n</code></pre>"},{"location":"reference/arms/#mabby.arms.Arm.play","title":"<code>play(rng)</code>  <code>abstractmethod</code>","text":"<p>Plays the arm and samples a reward.</p> <p>Parameters:</p> Name Type Description Default <code>rng</code> <code>Generator</code> <p>A random number generator.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The sampled reward from the arm's reward distribution.</p> Source code in <code>mabby/arms.py</code> <pre><code>@abstractmethod\ndef play(self, rng: Generator) -&gt; float:\n\"\"\"Plays the arm and samples a reward.\n\n    Args:\n        rng: A random number generator.\n\n    Returns:\n        The sampled reward from the arm's reward distribution.\n    \"\"\"\n</code></pre>"},{"location":"reference/arms/#mabby.arms.BernoulliArm","title":"<code>BernoulliArm(p)</code>","text":"<p>         Bases: <code>Arm</code></p> <p>Bandit arm with a Bernoulli reward distribution.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>float</code> <p>Parameter of the Bernoulli distribution.</p> required Source code in <code>mabby/arms.py</code> <pre><code>def __init__(self, p: float):\n\"\"\"Initializes a Bernoulli arm.\n\n    Args:\n        p: Parameter of the Bernoulli distribution.\n    \"\"\"\n    if p &lt; 0 or p &gt; 1:\n        raise ValueError(\n            f\"float {str(p)} is not a valid probability for Bernoulli distribution\"\n        )\n\n    self.p: float = p  #: Parameter of the Bernoulli distribution\n</code></pre>"},{"location":"reference/arms/#mabby.arms.GaussianArm","title":"<code>GaussianArm(loc, scale)</code>","text":"<p>         Bases: <code>Arm</code></p> <p>Bandit arm with a Gaussian reward distribution.</p> <p>Parameters:</p> Name Type Description Default <code>loc</code> <code>float</code> <p>Mean (\"center\") of the Gaussian distribution.</p> required <code>scale</code> <code>float</code> <p>Standard deviation of the Gaussian distribution.</p> required Source code in <code>mabby/arms.py</code> <pre><code>def __init__(self, loc: float, scale: float):\n\"\"\"Initializes a Gaussian arm.\n\n    Args:\n        loc: Mean (\"center\") of the Gaussian distribution.\n        scale: Standard deviation of the Gaussian distribution.\n    \"\"\"\n    if scale &lt; 0:\n        raise ValueError(\n            f\"float {str(scale)} is not a valid scale for Gaussian distribution\"\n        )\n\n    self.loc: float = loc  #: Mean (\"center\") of the Gaussian distribution\n    self.scale: float = scale  #: Standard deviation of the Gaussian distribution\n</code></pre>"},{"location":"reference/bandit/","title":"bandit","text":"<p>Provides <code>Bandit</code> class for bandit simulations.</p>"},{"location":"reference/bandit/#mabby.bandit.Bandit","title":"<code>Bandit(arms, rng=None, seed=None)</code>","text":"<p>Multi-armed bandit with one or more arms.</p> <p>This class wraps around a list of arms, each of which has a reward distribution. It provides an interface for interacting with the arms, such as playing a specific arm, querying for the optimal arm, and computing regret from a given choice.</p> <p>Parameters:</p> Name Type Description Default <code>arms</code> <code>list[Arm]</code> <p>A list of arms for the bandit.</p> required <code>rng</code> <code>Generator | None</code> <p>A random number generator.</p> <code>None</code> <code>seed</code> <code>int | None</code> <p>A seed for random number generation if <code>rng</code> is not provided.</p> <code>None</code> Source code in <code>mabby/bandit.py</code> <pre><code>def __init__(\n    self, arms: list[Arm], rng: Generator | None = None, seed: int | None = None\n):\n\"\"\"Initializes a bandit with a given set of arms.\n\n    Args:\n        arms: A list of arms for the bandit.\n        rng: A random number generator.\n        seed: A seed for random number generation if ``rng`` is not provided.\n    \"\"\"\n    self._arms = arms\n    self._rng = rng if rng else np.random.default_rng(seed)\n</code></pre>"},{"location":"reference/bandit/#mabby.bandit.Bandit.means","title":"<code>means: list[float]</code>  <code>property</code>","text":"<p>The means of the arms.</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>An array of the means of each arm.</p>"},{"location":"reference/bandit/#mabby.bandit.Bandit.__getitem__","title":"<code>__getitem__(i)</code>","text":"<p>Returns an arm by index.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int</code> <p>The index of the arm to get.</p> required <p>Returns:</p> Type Description <code>Arm</code> <p>The arm at the given index.</p> Source code in <code>mabby/bandit.py</code> <pre><code>def __getitem__(self, i: int) -&gt; Arm:\n\"\"\"Returns an arm by index.\n\n    Args:\n        i: The index of the arm to get.\n\n    Returns:\n        The arm at the given index.\n    \"\"\"\n    return self._arms[i]\n</code></pre>"},{"location":"reference/bandit/#mabby.bandit.Bandit.__iter__","title":"<code>__iter__()</code>","text":"<p>Returns an iterator over the bandit's arms.</p> Source code in <code>mabby/bandit.py</code> <pre><code>def __iter__(self) -&gt; Iterable[Arm]:\n\"\"\"Returns an iterator over the bandit's arms.\"\"\"\n    return iter(self._arms)\n</code></pre>"},{"location":"reference/bandit/#mabby.bandit.Bandit.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of arms.</p> Source code in <code>mabby/bandit.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Returns the number of arms.\"\"\"\n    return len(self._arms)\n</code></pre>"},{"location":"reference/bandit/#mabby.bandit.Bandit.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns a string representation of the bandit.</p> Source code in <code>mabby/bandit.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns a string representation of the bandit.\"\"\"\n    return repr(self._arms)\n</code></pre>"},{"location":"reference/bandit/#mabby.bandit.Bandit.best_arm","title":"<code>best_arm()</code>","text":"<p>Returns the index of the optimal arm.</p> <p>The optimal arm is the arm with the greatest expected reward. If there are multiple arms with equal expected rewards, a random one is chosen.</p> <p>Returns:</p> Type Description <code>int</code> <p>The index of the optimal arm.</p> Source code in <code>mabby/bandit.py</code> <pre><code>def best_arm(self) -&gt; int:\n\"\"\"Returns the index of the optimal arm.\n\n    The optimal arm is the arm with the greatest expected reward. If there are\n    multiple arms with equal expected rewards, a random one is chosen.\n\n    Returns:\n        The index of the optimal arm.\n    \"\"\"\n    return random_argmax(self.means, rng=self._rng)\n</code></pre>"},{"location":"reference/bandit/#mabby.bandit.Bandit.is_opt","title":"<code>is_opt(choice)</code>","text":"<p>Returns the optimality of a given choice.</p> <p>Parameters:</p> Name Type Description Default <code>choice</code> <code>int</code> <p>The index of the chosen arm.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the arm has the greatest expected reward, <code>False</code> otherwise.</p> Source code in <code>mabby/bandit.py</code> <pre><code>def is_opt(self, choice: int) -&gt; bool:\n\"\"\"Returns the optimality of a given choice.\n\n    Args:\n        choice: The index of the chosen arm.\n\n    Returns:\n        ``True`` if the arm has the greatest expected reward, ``False`` otherwise.\n    \"\"\"\n    return np.max(self.means) == self._arms[choice].mean\n</code></pre>"},{"location":"reference/bandit/#mabby.bandit.Bandit.play","title":"<code>play(i)</code>","text":"<p>Plays an arm by index.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int</code> <p>The index of the arm to play.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The reward from playing the arm.</p> Source code in <code>mabby/bandit.py</code> <pre><code>def play(self, i: int) -&gt; float:\n\"\"\"Plays an arm by index.\n\n    Args:\n        i: The index of the arm to play.\n\n    Returns:\n        The reward from playing the arm.\n    \"\"\"\n    return self[i].play(self._rng)\n</code></pre>"},{"location":"reference/bandit/#mabby.bandit.Bandit.regret","title":"<code>regret(choice)</code>","text":"<p>Returns the regret from a given choice.</p> <p>The regret is computed as the difference between the expected reward from the optimal arm and the expected reward from the chosen arm.</p> <p>Parameters:</p> Name Type Description Default <code>choice</code> <code>int</code> <p>The index of the chosen arm.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The computed regret value.</p> Source code in <code>mabby/bandit.py</code> <pre><code>def regret(self, choice: int) -&gt; float:\n\"\"\"Returns the regret from a given choice.\n\n    The regret is computed as the difference between the expected reward from the\n    optimal arm and the expected reward from the chosen arm.\n\n    Args:\n        choice: The index of the chosen arm.\n\n    Returns:\n        The computed regret value.\n    \"\"\"\n    return np.max(self.means) - self._arms[choice].mean\n</code></pre>"},{"location":"reference/exceptions/","title":"exceptions","text":"<p>Provides exceptions for mabby usage.</p>"},{"location":"reference/exceptions/#mabby.exceptions.AgentUsageError","title":"<code>AgentUsageError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raised when agent methods are used incorrectly.</p>"},{"location":"reference/exceptions/#mabby.exceptions.SimulationUsageError","title":"<code>SimulationUsageError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raised when simulation methods are used incorrectly.</p>"},{"location":"reference/exceptions/#mabby.exceptions.StatsUsageError","title":"<code>StatsUsageError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raised when stats methods are used incorrectly.</p>"},{"location":"reference/exceptions/#mabby.exceptions.StrategyUsageError","title":"<code>StrategyUsageError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raised when strategy methods are used incorrectly.</p>"},{"location":"reference/simulation/","title":"simulation","text":"<p>Provides <code>Simulation</code> class for bandit simulations.</p>"},{"location":"reference/simulation/#mabby.simulation.Simulation","title":"<code>Simulation(bandit, agents=None, strategies=None, names=None, rng=None, seed=None)</code>","text":"<p>Simulation of a multi-armed bandit problem.</p> <p>A simulation consists of multiple trials of one or more bandit strategies run on a configured multi-armed bandit.</p> <p>One of <code>agents</code> or <code>strategies</code> must be supplied. If <code>agents</code> is supplied, <code>strategies</code> and <code>names</code> are ignored. Otherwise, an <code>agent</code> is created for each <code>strategy</code> and given a name from <code>names</code> if available.</p> <p>Parameters:</p> Name Type Description Default <code>bandit</code> <code>Bandit</code> <p>A configured multi-armed bandit to simulate on.</p> required <code>agents</code> <code>Iterable[Agent] | None</code> <p>A list of agents to simulate.</p> <code>None</code> <code>strategies</code> <code>Iterable[Strategy] | None</code> <p>A list of strategies to simulate.</p> <code>None</code> <code>names</code> <code>Iterable[str] | None</code> <p>A list of names for agents.</p> <code>None</code> <code>rng</code> <code>Generator | None</code> <p>A random number generator.</p> <code>None</code> <code>seed</code> <code>int | None</code> <p>A seed for random number generation if <code>rng</code> is not provided.</p> <code>None</code> <p>Raises:</p> Type Description <code>SimulationUsageError</code> <p>If neither <code>agents</code> nor <code>strategies</code> are supplied.</p> Source code in <code>mabby/simulation.py</code> <pre><code>def __init__(\n    self,\n    bandit: Bandit,\n    agents: Iterable[Agent] | None = None,\n    strategies: Iterable[Strategy] | None = None,\n    names: Iterable[str] | None = None,\n    rng: Generator | None = None,\n    seed: int | None = None,\n):\n\"\"\"Initializes a simulation.\n\n    One of ``agents`` or ``strategies`` must be supplied. If ``agents`` is supplied,\n    ``strategies`` and ``names`` are ignored. Otherwise, an ``agent`` is created for\n    each ``strategy`` and given a name from ``names`` if available.\n\n    Args:\n        bandit: A configured multi-armed bandit to simulate on.\n        agents: A list of agents to simulate.\n        strategies: A list of strategies to simulate.\n        names: A list of names for agents.\n        rng: A random number generator.\n        seed: A seed for random number generation if ``rng`` is not provided.\n\n    Raises:\n        SimulationUsageError: If neither ``agents`` nor ``strategies`` are supplied.\n    \"\"\"\n    self.agents = self._create_agents(agents, strategies, names)\n    if len(list(self.agents)) == 0:\n        raise ValueError(\"no strategies or agents were supplied\")\n    self.bandit = bandit\n    if len(self.bandit) == 0:\n        raise ValueError(\"bandit cannot be empty\")\n    self._rng = rng if rng else np.random.default_rng(seed)\n</code></pre>"},{"location":"reference/simulation/#mabby.simulation.Simulation.run","title":"<code>run(trials, steps, metrics=None)</code>","text":"<p>Runs a simulation.</p> <p>In a simulation run, each agent or strategy is run for the specified number of trials, and each trial is run for the given number of steps.</p> <p>If <code>metrics</code> is not specified, all available metrics are tracked by default.</p> <p>Parameters:</p> Name Type Description Default <code>trials</code> <code>int</code> <p>The number of trials in the simulation.</p> required <code>steps</code> <code>int</code> <p>The number of steps in a trial.</p> required <code>metrics</code> <code>Iterable[Metric] | None</code> <p>A list of metrics to collect.</p> <code>None</code> <p>Returns:</p> Type Description <code>SimulationStats</code> <p>A <code>SimulationStats</code> object with the results of the simulation.</p> Source code in <code>mabby/simulation.py</code> <pre><code>def run(\n    self, trials: int, steps: int, metrics: Iterable[Metric] | None = None\n) -&gt; SimulationStats:\n\"\"\"Runs a simulation.\n\n    In a simulation run, each agent or strategy is run for the specified number of\n    trials, and each trial is run for the given number of steps.\n\n    If ``metrics`` is not specified, all available metrics are tracked by default.\n\n    Args:\n        trials: The number of trials in the simulation.\n        steps: The number of steps in a trial.\n        metrics: A list of metrics to collect.\n\n    Returns:\n        A ``SimulationStats`` object with the results of the simulation.\n    \"\"\"\n    sim_stats = SimulationStats(simulation=self)\n    for agent in self.agents:\n        agent_stats = self._run_trials_for_agent(agent, trials, steps, metrics)\n        sim_stats.add(agent_stats)\n    return sim_stats\n</code></pre>"},{"location":"reference/stats/","title":"stats","text":"<p>Provides metric tracking for multi-armed bandit simulations.</p>"},{"location":"reference/stats/#mabby.stats.AgentStats","title":"<code>AgentStats(agent, bandit, steps, metrics=None)</code>","text":"<p>Statistics for an agent in a multi-armed bandit simulation.</p> <p>All available metrics are tracked by default. Alternatively, a specific list can be specified through the <code>metrics</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>The agent that statistics are tracked for</p> required <code>bandit</code> <code>Bandit</code> <p>The bandit of the simulation being run</p> required <code>steps</code> <code>int</code> <p>The number of steps per trial in the simulation</p> required <code>metrics</code> <code>Iterable[Metric] | None</code> <p>A collection of metrics to track.</p> <code>None</code> Source code in <code>mabby/stats.py</code> <pre><code>def __init__(\n    self,\n    agent: Agent,\n    bandit: Bandit,\n    steps: int,\n    metrics: Iterable[Metric] | None = None,\n):\n\"\"\"Initializes agent statistics.\n\n    All available metrics are tracked by default. Alternatively, a specific list can\n    be specified through the ``metrics`` argument.\n\n    Args:\n        agent: The agent that statistics are tracked for\n        bandit: The bandit of the simulation being run\n        steps: The number of steps per trial in the simulation\n        metrics: A collection of metrics to track.\n    \"\"\"\n    self.agent: Agent = agent  #: The agent that statistics are tracked for\n    self._bandit = bandit\n    self._steps = steps\n    self._counts = np.zeros(steps)\n\n    base_metrics = Metric.map_to_base(list(Metric) if metrics is None else metrics)\n    self._stats = {stat: np.zeros(steps) for stat in base_metrics}\n</code></pre>"},{"location":"reference/stats/#mabby.stats.AgentStats.__getitem__","title":"<code>__getitem__(metric)</code>","text":"<p>Gets values for a metric.</p> <p>If the metric is not a base metric, the values are automatically transformed.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>Metric</code> <p>The metric to get the values for.</p> required <p>Returns:</p> Type Description <code>NDArray[np.float64]</code> <p>An array of values for the metric.</p> Source code in <code>mabby/stats.py</code> <pre><code>def __getitem__(self, metric: Metric) -&gt; NDArray[np.float64]:\n\"\"\"Gets values for a metric.\n\n    If the metric is not a base metric, the values are automatically transformed.\n\n    Args:\n        metric: The metric to get the values for.\n\n    Returns:\n        An array of values for the metric.\n    \"\"\"\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        values = self._stats[metric.base] / self._counts\n    return metric.transform(values)\n</code></pre>"},{"location":"reference/stats/#mabby.stats.AgentStats.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of steps each trial is tracked for.</p> Source code in <code>mabby/stats.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Returns the number of steps each trial is tracked for.\"\"\"\n    return self._steps\n</code></pre>"},{"location":"reference/stats/#mabby.stats.AgentStats.update","title":"<code>update(step, choice, reward)</code>","text":"<p>Updates metric values for the latest simulation step.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>int</code> <p>The number of the step.</p> required <code>choice</code> <code>int</code> <p>The choice made by the agent.</p> required <code>reward</code> <code>float</code> <p>The reward observed by the agent.</p> required Source code in <code>mabby/stats.py</code> <pre><code>def update(self, step: int, choice: int, reward: float) -&gt; None:\n\"\"\"Updates metric values for the latest simulation step.\n\n    Args:\n        step: The number of the step.\n        choice: The choice made by the agent.\n        reward: The reward observed by the agent.\n    \"\"\"\n    regret = self._bandit.regret(choice)\n    if Metric.REGRET in self._stats:\n        self._stats[Metric.REGRET][step] += regret\n    if Metric.OPTIMALITY in self._stats:\n        self._stats[Metric.OPTIMALITY][step] += int(self._bandit.is_opt(choice))\n    if Metric.REWARDS in self._stats:\n        self._stats[Metric.REWARDS][step] += reward\n    self._counts[step] += 1\n</code></pre>"},{"location":"reference/stats/#mabby.stats.Metric","title":"<code>Metric(label, base=None, transform=None)</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Enum for metrics that simulations can track.</p> <p>Metrics can be derived from other metrics through specifying a <code>base</code> metric and a <code>transform</code> function. This is useful for things like defining cumulative versions of an existing metric, where the transformed values can be computed \"lazily\" instead of being redundantly stored.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Verbose name of the metric (title case)</p> required <code>base</code> <code>str | None</code> <p>Name of the base metric</p> <code>None</code> <code>transform</code> <code>Callable[[NDArray[np.float64]], NDArray[np.float64]] | None</code> <p>Transformation function from the base metric</p> <code>None</code> Source code in <code>mabby/stats.py</code> <pre><code>def __init__(\n    self,\n    label: str,\n    base: str | None = None,\n    transform: Callable[[NDArray[np.float64]], NDArray[np.float64]] | None = None,\n):\n\"\"\"Initializes a metric.\n\n    Metrics can be derived from other metrics through specifying a ``base`` metric\n    and a ``transform`` function. This is useful for things like defining cumulative\n    versions of an existing metric, where the transformed values can be computed\n    \"lazily\" instead of being redundantly stored.\n\n    Args:\n        label: Verbose name of the metric (title case)\n        base: Name of the base metric\n        transform: Transformation function from the base metric\n    \"\"\"\n    self.__class__.__MAPPING__[self._name_] = self\n    self._label = label\n    self._mapping: MetricMapping | None = (\n        MetricMapping(base=self.__class__.__MAPPING__[base], transform=transform)\n        if base and transform\n        else None\n    )\n</code></pre>"},{"location":"reference/stats/#mabby.stats.Metric.base","title":"<code>base: Metric</code>  <code>property</code>","text":"<p>The base metric that the metric is transformed from.</p> <p>If the metric is already a base metric, the metric itself is returned.</p>"},{"location":"reference/stats/#mabby.stats.Metric.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the verbose name of the metric.</p> Source code in <code>mabby/stats.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the verbose name of the metric.\"\"\"\n    return self._label\n</code></pre>"},{"location":"reference/stats/#mabby.stats.Metric.is_base","title":"<code>is_base()</code>","text":"<p>Returns whether the metric is a base metric.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the metric is a base metric, <code>False</code> otherwise.</p> Source code in <code>mabby/stats.py</code> <pre><code>def is_base(self) -&gt; bool:\n\"\"\"Returns whether the metric is a base metric.\n\n    Returns:\n        ``True`` if the metric is a base metric, ``False`` otherwise.\n    \"\"\"\n    return self._mapping is None\n</code></pre>"},{"location":"reference/stats/#mabby.stats.Metric.map_to_base","title":"<code>map_to_base(metrics)</code>  <code>classmethod</code>","text":"<p>Traces all metrics back to their base metrics.</p> <p>Parameters:</p> Name Type Description Default <code>metrics</code> <code>Iterable[Metric]</code> <p>A collection of metrics.</p> required <p>Returns:</p> Type Description <code>Iterable[Metric]</code> <p>A set containing the base metrics of all the input metrics.</p> Source code in <code>mabby/stats.py</code> <pre><code>@classmethod\ndef map_to_base(cls, metrics: Iterable[Metric]) -&gt; Iterable[Metric]:\n\"\"\"Traces all metrics back to their base metrics.\n\n    Args:\n        metrics: A collection of metrics.\n\n    Returns:\n        A set containing the base metrics of all the input metrics.\n    \"\"\"\n    return set(m.base for m in metrics)\n</code></pre>"},{"location":"reference/stats/#mabby.stats.Metric.transform","title":"<code>transform(values)</code>","text":"<p>Transforms values from the base metric.</p> <p>If the metric is already a base metric, the input values are returned.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>NDArray[np.float64]</code> <p>An array of input values for the base metric.</p> required <p>Returns:</p> Type Description <code>NDArray[np.float64]</code> <p>An array of transformed values for the metric.</p> Source code in <code>mabby/stats.py</code> <pre><code>def transform(self, values: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n\"\"\"Transforms values from the base metric.\n\n    If the metric is already a base metric, the input values are returned.\n\n    Args:\n        values: An array of input values for the base metric.\n\n    Returns:\n        An array of transformed values for the metric.\n    \"\"\"\n    if self._mapping is not None:\n        return self._mapping.transform(values)\n    return values\n</code></pre>"},{"location":"reference/stats/#mabby.stats.MetricMapping","title":"<code>MetricMapping</code>  <code>dataclass</code>","text":"<p>Transformation from a base metric.</p> <p>See <code>Metric</code> for examples of metric mappings.</p>"},{"location":"reference/stats/#mabby.stats.SimulationStats","title":"<code>SimulationStats(simulation)</code>","text":"<p>Statistics for a multi-armed bandit simulation.</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>The simulation to track.</p> required Source code in <code>mabby/stats.py</code> <pre><code>def __init__(self, simulation: Simulation):\n\"\"\"Initializes simulation statistics.\n\n    Args:\n        simulation: The simulation to track.\n    \"\"\"\n    self._simulation: Simulation = simulation\n    self._stats_dict: dict[Agent, AgentStats] = {}\n</code></pre>"},{"location":"reference/stats/#mabby.stats.SimulationStats.__contains__","title":"<code>__contains__(agent)</code>","text":"<p>Returns if an agent's statistics are present.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if an agent's statistics are present, <code>False</code> otherwise.</p> Source code in <code>mabby/stats.py</code> <pre><code>def __contains__(self, agent: Agent) -&gt; bool:\n\"\"\"Returns if an agent's statistics are present.\n\n    Returns:\n        ``True`` if an agent's statistics are present, ``False`` otherwise.\n    \"\"\"\n    return agent in self._stats_dict\n</code></pre>"},{"location":"reference/stats/#mabby.stats.SimulationStats.__getitem__","title":"<code>__getitem__(agent)</code>","text":"<p>Gets statistics for an agent.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>The agent to get the statistics of.</p> required <p>Returns:</p> Type Description <code>AgentStats</code> <p>The statistics of the agent.</p> Source code in <code>mabby/stats.py</code> <pre><code>def __getitem__(self, agent: Agent) -&gt; AgentStats:\n\"\"\"Gets statistics for an agent.\n\n    Args:\n        agent: The agent to get the statistics of.\n\n    Returns:\n        The statistics of the agent.\n    \"\"\"\n    return self._stats_dict[agent]\n</code></pre>"},{"location":"reference/stats/#mabby.stats.SimulationStats.__setitem__","title":"<code>__setitem__(agent, agent_stats)</code>","text":"<p>Sets the statistics for an agent.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>The agent to set the statistics of.</p> required <code>agent_stats</code> <code>AgentStats</code> <p>The agent statistics to set.</p> required Source code in <code>mabby/stats.py</code> <pre><code>def __setitem__(self, agent: Agent, agent_stats: AgentStats) -&gt; None:\n\"\"\"Sets the statistics for an agent.\n\n    Args:\n        agent: The agent to set the statistics of.\n        agent_stats: The agent statistics to set.\n    \"\"\"\n    if agent != agent_stats.agent:\n        raise StatsUsageError(\"agents specified in key and value don't match\")\n    self._stats_dict[agent] = agent_stats\n</code></pre>"},{"location":"reference/stats/#mabby.stats.SimulationStats.add","title":"<code>add(agent_stats)</code>","text":"<p>Adds statistics for an agent.</p> <p>Parameters:</p> Name Type Description Default <code>agent_stats</code> <code>AgentStats</code> <p>The agent statistics to add.</p> required Source code in <code>mabby/stats.py</code> <pre><code>def add(self, agent_stats: AgentStats) -&gt; None:\n\"\"\"Adds statistics for an agent.\n\n    Args:\n        agent_stats: The agent statistics to add.\n    \"\"\"\n    self._stats_dict[agent_stats.agent] = agent_stats\n</code></pre>"},{"location":"reference/stats/#mabby.stats.SimulationStats.plot","title":"<code>plot(metric)</code>","text":"<p>Generates a plot for a simulation metric.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>Metric</code> <p>The metric to plot.</p> required Source code in <code>mabby/stats.py</code> <pre><code>def plot(self, metric: Metric) -&gt; None:\n\"\"\"Generates a plot for a simulation metric.\n\n    Args:\n        metric: The metric to plot.\n    \"\"\"\n    for agent, agent_stats in self._stats_dict.items():\n        plt.plot(agent_stats[metric], label=str(agent))\n    plt.legend()\n    plt.show()\n</code></pre>"},{"location":"reference/stats/#mabby.stats.SimulationStats.plot_optimality","title":"<code>plot_optimality()</code>","text":"<p>Generates a plot for the optimality metric.</p> Source code in <code>mabby/stats.py</code> <pre><code>def plot_optimality(self) -&gt; None:\n\"\"\"Generates a plot for the optimality metric.\"\"\"\n    self.plot(metric=Metric.OPTIMALITY)\n</code></pre>"},{"location":"reference/stats/#mabby.stats.SimulationStats.plot_regret","title":"<code>plot_regret(cumulative=True)</code>","text":"<p>Generates a plot for the regret or cumulative regret metrics.</p> <p>Parameters:</p> Name Type Description Default <code>cumulative</code> <code>bool</code> <p>Whether to use the cumulative regret.</p> <code>True</code> Source code in <code>mabby/stats.py</code> <pre><code>def plot_regret(self, cumulative: bool = True) -&gt; None:\n\"\"\"Generates a plot for the regret or cumulative regret metrics.\n\n    Args:\n        cumulative: Whether to use the cumulative regret.\n    \"\"\"\n    self.plot(metric=Metric.CUM_REGRET if cumulative else Metric.REGRET)\n</code></pre>"},{"location":"reference/stats/#mabby.stats.SimulationStats.plot_rewards","title":"<code>plot_rewards(cumulative=True)</code>","text":"<p>Generates a plot for the rewards or cumulative rewards metrics.</p> <p>Parameters:</p> Name Type Description Default <code>cumulative</code> <code>bool</code> <p>Whether to use the cumulative rewards.</p> <code>True</code> Source code in <code>mabby/stats.py</code> <pre><code>def plot_rewards(self, cumulative: bool = True) -&gt; None:\n\"\"\"Generates a plot for the rewards or cumulative rewards metrics.\n\n    Args:\n        cumulative: Whether to use the cumulative rewards.\n    \"\"\"\n    self.plot(metric=Metric.CUM_REWARDS if cumulative else Metric.REWARDS)\n</code></pre>"},{"location":"reference/utils/","title":"utils","text":"<p>Provides commonly used utility functions.</p>"},{"location":"reference/utils/#mabby.utils.random_argmax","title":"<code>random_argmax(values, rng)</code>","text":"<p>Computes random argmax of an array.</p> <p>If there are multiple maximums, the index of one is chosen at random.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>ArrayLike</code> <p>An input array.</p> required <code>rng</code> <code>Generator</code> <p>A random number generator.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The random argmax of the input array.</p> Source code in <code>mabby/utils.py</code> <pre><code>def random_argmax(values: ArrayLike, rng: Generator) -&gt; int:\n\"\"\"Computes random argmax of an array.\n\n    If there are multiple maximums, the index of one is chosen at random.\n\n    Args:\n        values: An input array.\n        rng: A random number generator.\n\n    Returns:\n        The random argmax of the input array.\n    \"\"\"\n    candidates = np.where(values == np.max(values))[0]\n    return int(rng.choice(candidates))\n</code></pre>"},{"location":"reference/strategies/","title":"strategies","text":"<p>Multi-armed bandit strategies.</p> <p>mabby provides a collection of preset bandit strategies that can be plugged into simulations. The <code>Strategy</code> abstract base class can also be sub-classed to implement custom bandit strategies.</p>"},{"location":"reference/strategies/#mabby.strategies.BetaTSStrategy","title":"<code>BetaTSStrategy(general=False)</code>","text":"<p>         Bases: <code>Strategy</code></p> <p>Thompson sampling strategy with Beta priors.</p> <p>If <code>general</code> is <code>False</code>, rewards used for updates must be either 0 or 1. Otherwise, rewards must be with support [0, 1].</p> <p>Parameters:</p> Name Type Description Default <code>general</code> <code>bool</code> <p>Whether to use a generalized version of the strategy.</p> <code>False</code> Source code in <code>mabby/strategies/thompson.py</code> <pre><code>def __init__(self, general: bool = False):\n\"\"\"Initializes a Beta Thompson sampling strategy.\n\n    If ``general`` is ``False``, rewards used for updates must be either 0 or 1.\n    Otherwise, rewards must be with support [0, 1].\n\n    Args:\n        general: Whether to use a generalized version of the strategy.\n    \"\"\"\n    self.general = general\n</code></pre>"},{"location":"reference/strategies/#mabby.strategies.EpsilonFirstStrategy","title":"<code>EpsilonFirstStrategy(eps)</code>","text":"<p>         Bases: <code>SemiUniformStrategy</code></p> <p>Epsilon-first bandit strategy.</p> <p>The epsilon-first strategy has a pure exploration phase followed by a pure exploitation phase.</p> <p>Parameters:</p> Name Type Description Default <code>eps</code> <code>float</code> <p>The ratio of exploration steps (must be between 0 and 1).</p> required Source code in <code>mabby/strategies/semi_uniform.py</code> <pre><code>def __init__(self, eps: float) -&gt; None:\n\"\"\"Initializes an epsilon-first strategy.\n\n    Args:\n        eps: The ratio of exploration steps (must be between 0 and 1).\n    \"\"\"\n    super().__init__()\n    if eps &lt; 0 or eps &gt; 1:\n        raise ValueError(\"eps must be between 0 and 1\")\n    self.eps = eps\n</code></pre>"},{"location":"reference/strategies/#mabby.strategies.EpsilonGreedyStrategy","title":"<code>EpsilonGreedyStrategy(eps)</code>","text":"<p>         Bases: <code>SemiUniformStrategy</code></p> <p>Epsilon-greedy bandit strategy.</p> <p>The epsilon-greedy strategy has a fixed chance of exploration every time step.</p> <p>Parameters:</p> Name Type Description Default <code>eps</code> <code>float</code> <p>The chance of exploration (must be between 0 and 1).</p> required Source code in <code>mabby/strategies/semi_uniform.py</code> <pre><code>def __init__(self, eps: float) -&gt; None:\n\"\"\"Initializes an epsilon-greedy strategy.\n\n    Args:\n        eps: The chance of exploration (must be between 0 and 1).\n    \"\"\"\n    super().__init__()\n    if eps &lt; 0 or eps &gt; 1:\n        raise ValueError(\"eps must be between 0 and 1\")\n    self.eps = eps\n</code></pre>"},{"location":"reference/strategies/#mabby.strategies.RandomStrategy","title":"<code>RandomStrategy()</code>","text":"<p>         Bases: <code>SemiUniformStrategy</code></p> <p>Random bandit strategy.</p> <p>The random strategy chooses arms at random, i.e., it explores with 100% chance.</p> Source code in <code>mabby/strategies/semi_uniform.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initializes a random strategy.\"\"\"\n    super().__init__()\n</code></pre>"},{"location":"reference/strategies/#mabby.strategies.SemiUniformStrategy","title":"<code>SemiUniformStrategy()</code>","text":"<p>         Bases: <code>Strategy</code>, <code>ABC</code>, <code>EnforceOverrides</code></p> <p>Base class for semi-uniform bandit strategies.</p> <p>Every semi-uniform strategy must implement <code>effective_eps</code> to compute the chance of exploration at each time step.</p> Source code in <code>mabby/strategies/semi_uniform.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initializes a semi-uniform strategy.\"\"\"\n</code></pre>"},{"location":"reference/strategies/#mabby.strategies.semi_uniform.SemiUniformStrategy.effective_eps","title":"<code>effective_eps()</code>  <code>abstractmethod</code>","text":"<p>Returns the effective epsilon value.</p> <p>The effective epsilon value is the probability at the current time step that the bandit will explore rather than exploit. Depending on the strategy, the effective epsilon value may be different from the nominal epsilon value set.</p> Source code in <code>mabby/strategies/semi_uniform.py</code> <pre><code>@abstractmethod\ndef effective_eps(self) -&gt; float:\n\"\"\"Returns the effective epsilon value.\n\n    The effective epsilon value is the probability at the current time step that the\n    bandit will explore rather than exploit. Depending on the strategy, the\n    effective epsilon value may be different from the nominal epsilon value set.\n    \"\"\"\n</code></pre>"},{"location":"reference/strategies/#mabby.strategies.Strategy","title":"<code>Strategy()</code>","text":"<p>         Bases: <code>ABC</code>, <code>EnforceOverrides</code></p> <p>Base class for a bandit strategy.</p> <p>A strategy provides the computational logic for choosing which bandit arms to play and updating parameter estimates.</p> Source code in <code>mabby/strategies/strategy.py</code> <pre><code>@abstractmethod\ndef __init__(self) -&gt; None:\n\"\"\"Initializes a bandit strategy.\"\"\"\n</code></pre>"},{"location":"reference/strategies/#mabby.strategies.strategy.Strategy.Ns","title":"<code>Ns: NDArray[np.uint32]</code>  <code>property</code> <code>abstractmethod</code>","text":"<p>The number of times each arm has been played.</p>"},{"location":"reference/strategies/#mabby.strategies.strategy.Strategy.Qs","title":"<code>Qs: NDArray[np.float64]</code>  <code>property</code> <code>abstractmethod</code>","text":"<p>The current estimated action values for each arm.</p>"},{"location":"reference/strategies/#mabby.strategies.strategy.Strategy.__repr__","title":"<code>__repr__()</code>  <code>abstractmethod</code>","text":"<p>Returns a string representation of the strategy.</p> Source code in <code>mabby/strategies/strategy.py</code> <pre><code>@abstractmethod\ndef __repr__(self) -&gt; str:\n\"\"\"Returns a string representation of the strategy.\"\"\"\n</code></pre>"},{"location":"reference/strategies/#mabby.strategies.strategy.Strategy.agent","title":"<code>agent(**kwargs)</code>","text":"<p>Creates an agent following the strategy.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>str</code> <p>Parameters for initializing the agent (see <code>Agent</code>)</p> <code>{}</code> <p>Returns:</p> Type Description <code>Agent</code> <p>The created agent with the strategy.</p> Source code in <code>mabby/strategies/strategy.py</code> <pre><code>def agent(self, **kwargs: str) -&gt; Agent:\n\"\"\"Creates an agent following the strategy.\n\n    Args:\n        **kwargs: Parameters for initializing the agent (see\n            [`Agent`][mabby.agent.Agent])\n\n    Returns:\n        The created agent with the strategy.\n    \"\"\"\n    return Agent(strategy=self, **kwargs)\n</code></pre>"},{"location":"reference/strategies/#mabby.strategies.strategy.Strategy.choose","title":"<code>choose(rng)</code>  <code>abstractmethod</code>","text":"<p>Returns the next arm to play.</p> <p>Parameters:</p> Name Type Description Default <code>rng</code> <code>Generator</code> <p>A random number generator.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The index of the arm to play.</p> Source code in <code>mabby/strategies/strategy.py</code> <pre><code>@abstractmethod\ndef choose(self, rng: Generator) -&gt; int:\n\"\"\"Returns the next arm to play.\n\n    Args:\n        rng: A random number generator.\n\n    Returns:\n        The index of the arm to play.\n    \"\"\"\n</code></pre>"},{"location":"reference/strategies/#mabby.strategies.strategy.Strategy.prime","title":"<code>prime(k, steps)</code>  <code>abstractmethod</code>","text":"<p>Primes the strategy before running a trial.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>The number of bandit arms to choose from.</p> required <code>steps</code> <code>int</code> <p>The number of steps to the simulation will be run.</p> required Source code in <code>mabby/strategies/strategy.py</code> <pre><code>@abstractmethod\ndef prime(self, k: int, steps: int) -&gt; None:\n\"\"\"Primes the strategy before running a trial.\n\n    Args:\n        k: The number of bandit arms to choose from.\n        steps: The number of steps to the simulation will be run.\n    \"\"\"\n</code></pre>"},{"location":"reference/strategies/#mabby.strategies.strategy.Strategy.update","title":"<code>update(choice, reward, rng=None)</code>  <code>abstractmethod</code>","text":"<p>Updates internal parameter estimates based on reward observation.</p> <p>Parameters:</p> Name Type Description Default <code>choice</code> <code>int</code> <p>The most recent choice made.</p> required <code>reward</code> <code>float</code> <p>The observed reward from the agent's most recent choice.</p> required <code>rng</code> <code>Generator | None</code> <p>A random number generator.</p> <code>None</code> Source code in <code>mabby/strategies/strategy.py</code> <pre><code>@abstractmethod\ndef update(self, choice: int, reward: float, rng: Generator | None = None) -&gt; None:\n\"\"\"Updates internal parameter estimates based on reward observation.\n\n    Args:\n        choice: The most recent choice made.\n        reward: The observed reward from the agent's most recent choice.\n        rng: A random number generator.\n    \"\"\"\n</code></pre>"},{"location":"reference/strategies/#mabby.strategies.UCB1Strategy","title":"<code>UCB1Strategy(alpha)</code>","text":"<p>         Bases: <code>Strategy</code></p> <p>Strategy using the UCB1 bandit algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>The exploration parameter.</p> required Source code in <code>mabby/strategies/ucb.py</code> <pre><code>def __init__(self, alpha: float) -&gt; None:\n\"\"\"Initializes a UCB1 strategy.\n\n    Args:\n        alpha: The exploration parameter.\n    \"\"\"\n    if alpha &lt; 0:\n        raise ValueError(\"alpha must be greater than 0\")\n    self.alpha = alpha\n</code></pre>"},{"location":"reference/strategies/semi_uniform/","title":"semi_uniform","text":"<p>Provides implementations of semi-uniform bandit strategies.</p> <p>Semi-uniform strategies will choose to explore or exploit at each time step. When exploring, a random arm will be played. When exploiting, the arm with the greatest estimated action value will be played. <code>epsilon</code>, the chance of exploration, is computed differently with different semi-uniform strategies.</p>"},{"location":"reference/strategies/semi_uniform/#mabby.strategies.semi_uniform.EpsilonFirstStrategy","title":"<code>EpsilonFirstStrategy(eps)</code>","text":"<p>         Bases: <code>SemiUniformStrategy</code></p> <p>Epsilon-first bandit strategy.</p> <p>The epsilon-first strategy has a pure exploration phase followed by a pure exploitation phase.</p> <p>Parameters:</p> Name Type Description Default <code>eps</code> <code>float</code> <p>The ratio of exploration steps (must be between 0 and 1).</p> required Source code in <code>mabby/strategies/semi_uniform.py</code> <pre><code>def __init__(self, eps: float) -&gt; None:\n\"\"\"Initializes an epsilon-first strategy.\n\n    Args:\n        eps: The ratio of exploration steps (must be between 0 and 1).\n    \"\"\"\n    super().__init__()\n    if eps &lt; 0 or eps &gt; 1:\n        raise ValueError(\"eps must be between 0 and 1\")\n    self.eps = eps\n</code></pre>"},{"location":"reference/strategies/semi_uniform/#mabby.strategies.semi_uniform.EpsilonGreedyStrategy","title":"<code>EpsilonGreedyStrategy(eps)</code>","text":"<p>         Bases: <code>SemiUniformStrategy</code></p> <p>Epsilon-greedy bandit strategy.</p> <p>The epsilon-greedy strategy has a fixed chance of exploration every time step.</p> <p>Parameters:</p> Name Type Description Default <code>eps</code> <code>float</code> <p>The chance of exploration (must be between 0 and 1).</p> required Source code in <code>mabby/strategies/semi_uniform.py</code> <pre><code>def __init__(self, eps: float) -&gt; None:\n\"\"\"Initializes an epsilon-greedy strategy.\n\n    Args:\n        eps: The chance of exploration (must be between 0 and 1).\n    \"\"\"\n    super().__init__()\n    if eps &lt; 0 or eps &gt; 1:\n        raise ValueError(\"eps must be between 0 and 1\")\n    self.eps = eps\n</code></pre>"},{"location":"reference/strategies/semi_uniform/#mabby.strategies.semi_uniform.RandomStrategy","title":"<code>RandomStrategy()</code>","text":"<p>         Bases: <code>SemiUniformStrategy</code></p> <p>Random bandit strategy.</p> <p>The random strategy chooses arms at random, i.e., it explores with 100% chance.</p> Source code in <code>mabby/strategies/semi_uniform.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initializes a random strategy.\"\"\"\n    super().__init__()\n</code></pre>"},{"location":"reference/strategies/semi_uniform/#mabby.strategies.semi_uniform.SemiUniformStrategy","title":"<code>SemiUniformStrategy()</code>","text":"<p>         Bases: <code>Strategy</code>, <code>ABC</code>, <code>EnforceOverrides</code></p> <p>Base class for semi-uniform bandit strategies.</p> <p>Every semi-uniform strategy must implement <code>effective_eps</code> to compute the chance of exploration at each time step.</p> Source code in <code>mabby/strategies/semi_uniform.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initializes a semi-uniform strategy.\"\"\"\n</code></pre>"},{"location":"reference/strategies/semi_uniform/#mabby.strategies.semi_uniform.SemiUniformStrategy.effective_eps","title":"<code>effective_eps()</code>  <code>abstractmethod</code>","text":"<p>Returns the effective epsilon value.</p> <p>The effective epsilon value is the probability at the current time step that the bandit will explore rather than exploit. Depending on the strategy, the effective epsilon value may be different from the nominal epsilon value set.</p> Source code in <code>mabby/strategies/semi_uniform.py</code> <pre><code>@abstractmethod\ndef effective_eps(self) -&gt; float:\n\"\"\"Returns the effective epsilon value.\n\n    The effective epsilon value is the probability at the current time step that the\n    bandit will explore rather than exploit. Depending on the strategy, the\n    effective epsilon value may be different from the nominal epsilon value set.\n    \"\"\"\n</code></pre>"},{"location":"reference/strategies/strategy/","title":"strategy","text":"<p>Provides <code>Strategy</code> class.</p>"},{"location":"reference/strategies/strategy/#mabby.strategies.strategy.Strategy","title":"<code>Strategy()</code>","text":"<p>         Bases: <code>ABC</code>, <code>EnforceOverrides</code></p> <p>Base class for a bandit strategy.</p> <p>A strategy provides the computational logic for choosing which bandit arms to play and updating parameter estimates.</p> Source code in <code>mabby/strategies/strategy.py</code> <pre><code>@abstractmethod\ndef __init__(self) -&gt; None:\n\"\"\"Initializes a bandit strategy.\"\"\"\n</code></pre>"},{"location":"reference/strategies/strategy/#mabby.strategies.strategy.Strategy.Ns","title":"<code>Ns: NDArray[np.uint32]</code>  <code>property</code> <code>abstractmethod</code>","text":"<p>The number of times each arm has been played.</p>"},{"location":"reference/strategies/strategy/#mabby.strategies.strategy.Strategy.Qs","title":"<code>Qs: NDArray[np.float64]</code>  <code>property</code> <code>abstractmethod</code>","text":"<p>The current estimated action values for each arm.</p>"},{"location":"reference/strategies/strategy/#mabby.strategies.strategy.Strategy.__repr__","title":"<code>__repr__()</code>  <code>abstractmethod</code>","text":"<p>Returns a string representation of the strategy.</p> Source code in <code>mabby/strategies/strategy.py</code> <pre><code>@abstractmethod\ndef __repr__(self) -&gt; str:\n\"\"\"Returns a string representation of the strategy.\"\"\"\n</code></pre>"},{"location":"reference/strategies/strategy/#mabby.strategies.strategy.Strategy.agent","title":"<code>agent(**kwargs)</code>","text":"<p>Creates an agent following the strategy.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>str</code> <p>Parameters for initializing the agent (see <code>Agent</code>)</p> <code>{}</code> <p>Returns:</p> Type Description <code>Agent</code> <p>The created agent with the strategy.</p> Source code in <code>mabby/strategies/strategy.py</code> <pre><code>def agent(self, **kwargs: str) -&gt; Agent:\n\"\"\"Creates an agent following the strategy.\n\n    Args:\n        **kwargs: Parameters for initializing the agent (see\n            [`Agent`][mabby.agent.Agent])\n\n    Returns:\n        The created agent with the strategy.\n    \"\"\"\n    return Agent(strategy=self, **kwargs)\n</code></pre>"},{"location":"reference/strategies/strategy/#mabby.strategies.strategy.Strategy.choose","title":"<code>choose(rng)</code>  <code>abstractmethod</code>","text":"<p>Returns the next arm to play.</p> <p>Parameters:</p> Name Type Description Default <code>rng</code> <code>Generator</code> <p>A random number generator.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The index of the arm to play.</p> Source code in <code>mabby/strategies/strategy.py</code> <pre><code>@abstractmethod\ndef choose(self, rng: Generator) -&gt; int:\n\"\"\"Returns the next arm to play.\n\n    Args:\n        rng: A random number generator.\n\n    Returns:\n        The index of the arm to play.\n    \"\"\"\n</code></pre>"},{"location":"reference/strategies/strategy/#mabby.strategies.strategy.Strategy.prime","title":"<code>prime(k, steps)</code>  <code>abstractmethod</code>","text":"<p>Primes the strategy before running a trial.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>The number of bandit arms to choose from.</p> required <code>steps</code> <code>int</code> <p>The number of steps to the simulation will be run.</p> required Source code in <code>mabby/strategies/strategy.py</code> <pre><code>@abstractmethod\ndef prime(self, k: int, steps: int) -&gt; None:\n\"\"\"Primes the strategy before running a trial.\n\n    Args:\n        k: The number of bandit arms to choose from.\n        steps: The number of steps to the simulation will be run.\n    \"\"\"\n</code></pre>"},{"location":"reference/strategies/strategy/#mabby.strategies.strategy.Strategy.update","title":"<code>update(choice, reward, rng=None)</code>  <code>abstractmethod</code>","text":"<p>Updates internal parameter estimates based on reward observation.</p> <p>Parameters:</p> Name Type Description Default <code>choice</code> <code>int</code> <p>The most recent choice made.</p> required <code>reward</code> <code>float</code> <p>The observed reward from the agent's most recent choice.</p> required <code>rng</code> <code>Generator | None</code> <p>A random number generator.</p> <code>None</code> Source code in <code>mabby/strategies/strategy.py</code> <pre><code>@abstractmethod\ndef update(self, choice: int, reward: float, rng: Generator | None = None) -&gt; None:\n\"\"\"Updates internal parameter estimates based on reward observation.\n\n    Args:\n        choice: The most recent choice made.\n        reward: The observed reward from the agent's most recent choice.\n        rng: A random number generator.\n    \"\"\"\n</code></pre>"},{"location":"reference/strategies/thompson/","title":"thompson","text":"<p>Provides implementations of Thompson sampling strategies.</p>"},{"location":"reference/strategies/thompson/#mabby.strategies.thompson.BetaTSStrategy","title":"<code>BetaTSStrategy(general=False)</code>","text":"<p>         Bases: <code>Strategy</code></p> <p>Thompson sampling strategy with Beta priors.</p> <p>If <code>general</code> is <code>False</code>, rewards used for updates must be either 0 or 1. Otherwise, rewards must be with support [0, 1].</p> <p>Parameters:</p> Name Type Description Default <code>general</code> <code>bool</code> <p>Whether to use a generalized version of the strategy.</p> <code>False</code> Source code in <code>mabby/strategies/thompson.py</code> <pre><code>def __init__(self, general: bool = False):\n\"\"\"Initializes a Beta Thompson sampling strategy.\n\n    If ``general`` is ``False``, rewards used for updates must be either 0 or 1.\n    Otherwise, rewards must be with support [0, 1].\n\n    Args:\n        general: Whether to use a generalized version of the strategy.\n    \"\"\"\n    self.general = general\n</code></pre>"},{"location":"reference/strategies/ucb/","title":"ucb","text":"<p>Provides implementations of upper confidence bound (UCB) strategies.</p>"},{"location":"reference/strategies/ucb/#mabby.strategies.ucb.UCB1Strategy","title":"<code>UCB1Strategy(alpha)</code>","text":"<p>         Bases: <code>Strategy</code></p> <p>Strategy using the UCB1 bandit algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>The exploration parameter.</p> required Source code in <code>mabby/strategies/ucb.py</code> <pre><code>def __init__(self, alpha: float) -&gt; None:\n\"\"\"Initializes a UCB1 strategy.\n\n    Args:\n        alpha: The exploration parameter.\n    \"\"\"\n    if alpha &lt; 0:\n        raise ValueError(\"alpha must be greater than 0\")\n    self.alpha = alpha\n</code></pre>"}]}